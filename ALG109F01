#include <unistd.h>
#include <unordered_map>
#include <vector>
#include <iostream>
#include <queue>
#include <set>
#include <cmath>
#include <ctime>
#include <fstream>
#include <iomanip>


using namespace std;

#define ALPHA 2
#define BETA 5
#define RHO 0.7
#define ANTS 5
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

double randFloat(double lowerbound, double upperbound);

class road {
   public:
    road() {}
    road(class city *A, class city *B, double w);

    class city *A, *B;
    double w;
    double re_w, Pheromones, score;
};

class city {
   public:
    city(){};
    city(int n, double x, double y);

    double x, y;
    int number;
    unordered_map<int, road *> to;

   private:
};
class ants {
   public:
    ants() { distance = 0; }
    vector<road *> PATH;
    double distance;

    friend bool operator<(const ants &c1, const ants &c2) {
        return c1.distance < c2.distance;
    }
    friend bool operator>(const ants &c1, const ants &c2) {
        return c1.distance > c2.distance;
    }
};

class country {
   public:
    country() {}

    void insertCity(int number, double x, double y);
    void insertRoad(double w);
    void init();
    double ACO();
    double Euclidean(int from, int to);
    void print();
    void printpath(ants);
    void clear();

    vector<city> CITY;
    int Roulette(int start, set<int> S);
    double GetWheel(int start, set<int> S);
};

road::road(city *A, city *B, double w)
{
    this->A = A;
    this->B = B;
    this->w = w;
    this->re_w = 1 / w;
    this->Pheromones = 1000;
    this->score = re_w * Pheromones;
}
city::city(int n, double x, double y)
{
    this->number = n;
    this->x = x;
    this->y = y;
}

void country::insertCity(int number, double x, double y)
{
    CITY.push_back(city(number, x, y));
}
void country::init() {
    for (int i = 0; i < CITY.size(); i++)
    {
        for (int j = i + 1; j < CITY.size(); j++)
        {
            double distance = Euclidean(i, j);
            road *tmp = new road(&CITY[i], &CITY[j], distance);
            CITY[i].to.insert(std::pair<int, road *>(j, tmp));
            CITY[j].to.insert(std::pair<int, road *>(i, tmp));
        }
    }
}
double country::ACO()
{
    init();
    double min_distance = DBL_MAX;
    for (int t = 0; t < 700; t++)
    {
        priority_queue<ants, vector<ants>, std::greater<ants>> ANTs;
        set<int> S;
        for (int a = 0; a < ANTS; a++)
        {
            ants walker;
            int start = rand() % CITY.size();
            int end = start;
            for (int i = 0; i < CITY.size(); i++) {
                S.insert(start);
                int next = Roulette(start, S);
                if (next == -1) break;

                walker.distance += CITY[start].to[next]->w;
                walker.PATH.push_back(CITY[start].to[next]);

                start = next;
            }

            walker.distance += CITY[start].to[end]->w;
            walker.PATH.push_back(CITY[start].to[end]);

            S.clear();
            ANTs.push(walker);
        }

        if (ANTs.size() && min_distance > ANTs.top().distance)
        {
            min_distance = ANTs.top().distance;  // find distance;
        }

        for (int i = 0; i < CITY.size(); i++) {
            for (int j = i + 1; j < CITY.size(); j++) {
                CITY[i].to[j]->Pheromones *= RHO;
            }
        }

        for (int a = 0; a < ANTs.size(); a++) {
            double dis = 1 / ANTs.top().distance;
            for (int i = 0; i < ANTs.top().PATH.size(); i++) {
                ANTs.top().PATH[i]->Pheromones += dis;
            }
            ANTs.pop();
        }

        for (int i = 0; i < CITY.size(); i++) {
            for (int j = i + 1; j < CITY.size(); j++) {
                double tmp = ALPHA * CITY[i].to[j]->re_w * BETA * CITY[i].to[j]->Pheromones;
                if (tmp == 0) tmp = DBL_MIN;
                CITY[i].to[j]->score = tmp;
            }
        }
    }
    return min_distance;
}

double country::Euclidean(int from, int to)
{
    return sqrt((CITY[from].x - CITY[to].x) * (CITY[from].x - CITY[to].x) + (CITY[from].y - CITY[to].y) * (CITY[from].y - CITY[to].y));
}

void country::clear()
{
    for (int i = 0; i < CITY.size(); i++) {
        for (int j = i + 1; j < CITY.size(); j++) {
            delete CITY[i].to[j];
        }
    }
    CITY.clear();
    return;
}

int country::Roulette(int start, set<int> S)
{
    double wheel = GetWheel(start, S);
    wheel = randFloat(0, wheel);
    int next = -1;
    for (int i = 0; i < CITY.size() && wheel >= 0; i++)
    {
        if (S.count(i)) continue;
        wheel -= CITY[start].to[i]->score;
        next = i;
    }
    return next;
}
double country::GetWheel(int start, set<int> S)
{
    double wheel = 0;
    for (int i = 0; i < CITY.size(); i++)
    {
        if (S.count(i)) continue;
        wheel += CITY[start].to[i]->score;
    }
    return wheel;
}

double randFloat(double lowerbound, double upperbound)
{
    return double(rand()) / (RAND_MAX) * (upperbound - lowerbound) + lowerbound;
}


int main(void) {
    srand(time(nullptr));

    int n, t = 0;
    double x, y;
    country myhome;
    double ans = 0;

    while (cin >> n >> x >> y)
        myhome.insertCity(n, x, y);

    cout << myhome.ACO() << endl;

    return 0;
}
